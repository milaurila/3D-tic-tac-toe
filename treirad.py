import itertools as it
import matplotlib.pyplot as plt
import numpy as np
import random

# X is represented by 1.
# O is represented by -1.
# A draw is represented by 0.
# X (1) always plays the first move.

def create_board(dim, size, scenario):
    """Initializes board to be played on.

    Arguments:
    dim (int) -- Dimension of board.
    size (int) -- Size of board (2D exclusive).
    scenario (int) -- Determines boards center square value.
                      If 1, board is all zeros.
                      If 2, boards middle square is set to one (1).
    Valid Values:
    dim -- 1 and 2.
    size -- If dim is 2, any odd number greater than 1.
            If dim is 3, only 3.
    scenario -- 1 and 2.
    Returns:
    board (numpy array) -- Board with layout specified by arguments.

    Invokes NumPy's zeros() method to create an array with a zero
    in every position. If scenario is set to 2 the method itemset()
    inserts a one (1) in the center position. Center is obtained with
    whole number division by 2 of the board size. This works since
    board size always is odd and index starts at 0.
    """

    if dim == 2:
        if scenario == 1:
            board = np.zeros((size,size), dtype = int)

        if scenario == 2:
            center = size // 2
            board = np.zeros((size,size), dtype = int)
            board.itemset((center,center), 1)
    if dim == 3:
        if scenario == 1:
            board = np.zeros((dim,dim,dim), dtype = int)

        if scenario == 2:
            center = size // 2
            board = np.zeros((dim,dim,dim), dtype = int)
            board.itemset((0,center,center), 1)

    return board

def valid_move(board):
    """Returns a random unoccupied (is = 0) square on argument board.

    Argument:
    board (numpy array) -- Board being played on by function game().
    Returns:
    next_move (tuple) -- Index for numpy array.
    False -- If list not_played is empty (no valid moves left, i.e.
                                          board has no zero elements).

    Uses condition (== 0) in NumPy method nonzero() on argument board
    to get indices of all squares that are equal to zero. nonzero()
    returns a tuple of arrays with row and column indices respectively,
    these are merged into tuples with zip().
    choice() from random module chooses a random valid move from list
    not_played.
    """

    valid = (board == 0).nonzero()
    not_played = [(m,n) for m, n in zip(valid[0], valid[1])]
    if len(not_played) == 0:
        return False

    next_move = random.choice(not_played)
    return next_move

def square_star(board, square):
    """Generates arrays of square's row, column and diagonals ('rays').

    Arguments:
    board (numpy array) -- Board containing argument square.
    square (tuple) -- Square index.
    Returns:
    star (list of numpy arrays) -- Square rays.

    Uses square index to select rays of interest on the argument board.
    Variable 'diag_shift' is used to obtain the minor diagonals passing
    through the square (main diagonals offset 0, upwards offset is
    positive, downwards is negative). Anti diagonal is obtained by
    flipping the board left-to-right and negating the diagonal shift.
    """

    m, n = square
    diag_shift = n - m

    row = board[m, :]
    column = board[:, n]
    diagonal = board.diagonal(offset=diag_shift)
    anti_diagonal = np.fliplr(board).diagonal(offset=-diag_shift)

    star = [row, column, diagonal, anti_diagonal]
    return star

def win_check(star):
    """Checks rays in star for consecutive elements with abs(sum) = 3.

    Argument:
    star (list of numpy arrays) -- Star generated by square_star().
    Returns:
    True -- If a winning sum (3) is found.
    False -- If a winning sum is not found in any of the rays.

    While loop only checks rays with minimum length 3. Sums elements
    in ray in intervals of three. NumPy array attribute "size" returns
    the length of an array.
    """

    for ray in star:
        i = 0
        while i <= ray.size - 3:
            three_sum = sum(ray[i:i+3])
            if abs(three_sum) == 3:
                return True
            i += 1
    return False

def game(board):
    """Plays a game.

    Argument:
    board (numpy array) -- Board created by create_board().
    Returns:
    0 (int) -- If valid_move() returns False (no valid moves left on
    board). Represents a draw.
    board[move] (numpy array element) -- If win_check() returns True
    (detected a win).

    Itertools method cycle() is used to alternate between players.
    Number of plays is determined by board size and scenario.
    A star is generated every time a move is made and checked for a win
    by win_check(). Since a win check is preformed after each move
    the value of board[move] represents which player made the winning
    move in case of a win.
    """

    marker = it.cycle([-1,1])
    center = board.shape[0] // 2
    if board[center, center] == 0: # If scenario 1, it is X's (1) turn.
        next(marker)

    for i in range(board.size + 1 - board[center, center]):
        move = valid_move(board)
        if not move:
            return 0
        board.itemset(move, next(marker)) # Place marker at valid move (index).
        star = square_star(board, move)
        if win_check(star):
            return board[move]

def valid_move_3d(board):
    """Returns a random unoccupied (is = 0) cube on argument board.

    Argument:
    board (numpy array) -- Board being played on by function game().
    Returns:
    next_move (tuple) -- Index for numpy array.
    False -- If list not_played is empty (no valid moves left, i.e.
                                          board has no zero elements).

    See docstring of valid_move() for details.
    When a random valid move with 0th index > 0 is picked, the while
    loop checks if the position beneath (whose 0th index is smaller)
    is occupied. If it is vacant (is in list not_played) the 0th
    index of the move is lowered by one and checked until it is 0
    (at the bottom layer) or the position below is occupied.
    """

    valid = (board == 0).nonzero()
    not_played = [(m,n,o) for m, n, o in zip(valid[0], valid[1], valid[2])]
    if len(not_played) == 0:
        return False

    next_move = random.choice(not_played)
    while next_move[0] > 0:
        if (next_move[0]-1, next_move[1], next_move[2]) in not_played:
            next_move = (next_move[0]-1, next_move[1], next_move[2])
        else:
            return next_move
    return next_move

def cube_star(board, cube):
    """Generates arrays of cube's row, column and pillar and board's diagonals.

    Arguments:
    board (numpy array) -- Board containing argument cube.
    cube (tuple) -- Cube index.
    Returns:
    star (list of numpy arrays) -- Cube and board rays.

    Uses cube index to select rays of interest on the argument board as
    in square_star() with the addition of the "pillar" ray in the
    z-direction (0th index).
    This monstrosity generates arrays of all of the board's main diagonals.
    The four diametric diagonals are hard coded. The others are obtained by
    rotating the board 90 degrees clock- and anticlockwise around each
    dimensional axis and at each rotation calling the diagonal() method.
    This produces three sets of 3x6 arrays that are turned into 1x18
    arrays with the method flatten(). These are then extended into the list
    "star" in chunks of 1x3 arrays via the method split().
    """

    l, m, n = cube
    v_diags = np.vstack((board.diagonal(), np.rot90(board, 1).diagonal())).flatten()
    h_diags = np.vstack((np.rot90(board,1,(1,2)).diagonal(), np.rot90(board,1,(2,1)).diagonal())).flatten()
    d_diags = np.vstack((np.rot90(board,1,(2,0)).diagonal(), np.rot90(board,1,(0,2)).diagonal())).flatten()
    diam_diags = np.array([[board[0,0,0],board[1,1,1],board[2,2,2]],
                          [board[0,0,2],board[1,1,1],board[2,2,0]],
                          [board[0,2,0],board[1,1,1],board[2,0,2]],
                          [board[0,2,2],board[1,1,1],board[2,0,0]]]).flatten()

    pillar = board[:, m, n]
    row = board[l, m, :]
    column = board[l, :, n]

    star = [pillar, row, column]
    star.extend(np.split(v_diags, 6))
    star.extend(np.split(h_diags, 6))
    star.extend(np.split(d_diags, 6))
    star.extend(np.split(diam_diags, 4))
    return star

def game_3d(board):
    """Plays a game.

    Argument:
    board (numpy array) -- Board created by create_board().
    Returns:
    0 (int) -- If valid_move() returns False (no valid moves left on
    board). Represents a draw.
    board[move] (numpy array element) -- If win_check() returns True
    (detected a win).

    Itertools method cycle() is used to alternate between players.
    Number of plays is determined by board size and scenario.
    A star is generated every time a move is made and checked for a win
    by win_check(). Since a win check is preformed after each move
    the value of board[move] represents which player made the winning
    move in case of a win.
    """

    marker = it.cycle([-1,1])
    center = board.shape[0] // 2
    if board[0, center, center] == 0:
        next(marker)

    for i in range(board.size + 1 - board[0, center, center]):
        move = valid_move_3d(board)
        if not move:
            return 0
        board.itemset(move, next(marker))
        star = cube_star(board, move)
        if win_check(star):
            return board[move]

def simulation(dim, board_size, scenario, rounds):
    """Simulates a game "rounds" number of times.

    Arguments:
    dim (int) -- Dimension of board.
    board_size (int) -- Board size (2D exclusive).
    scenario (int) -- Determines boards initial center value.
    rounds (int) -- Number of rounds to be simulated.
    Valid Values:
    board_size (int) -- Although 2D exclusive must be set to 3 for 3D.
    Returns:
    crosses (int) -- Number of X wins.
    noughts (int) -- Number of O wins.
    draws (int) -- Number of draws.
    rounds (int) -- Number of rounds played.

    Creates a board and invokes a game on it. The game's return value
    is tallied into "crosses", "noughts" and "draws".
    """

    crosses = 0
    noughts = 0
    draws = 0

    for games in range(rounds):
        board = create_board(dim, board_size, scenario)
        if dim == 2:
            result = game(board)
        elif dim == 3:
            result = game_3d(board)
        if result == 1: # X win.
            crosses += 1
        elif result == -1: # O win.
            noughts += 1
        elif result == 0: # Draw.
            draws += 1
    return crosses, noughts, draws, rounds

def plot_results(xs, os, draws, rounds, dim, size, scenario):
    """Creates file 'utfall.pdf' with plot of simulation() results.

    Arguments:
    xs (int) -- Number of X wins.
    os (int) -- Number of O wins.
    draws (int) -- Numver of draws.
    rounds (int) -- Number of rounds played in simulation.
    dim (int) -- Dimension of the board played on.
    size (int) -- Size of the board played on.
    scenario (int) -- Scenario which was played.
    Returns:
    None -- Saves plot to file 'utfall.pdf'.

    Takes data from simulation and creates a plot of results
    with Matplotlibs pyplot.
    """

    plt.clf()
    labels = ['Spelare 1', 'Spelare 2', 'Oavgjort']
    results = [xs, os, draws]
    plt.bar(labels, results)
    if dim == 2:
        plt.suptitle(f'Utfall av {rounds} partier Tre-i-rad på ett'
                     f' {size}x{size}-bräde')
    elif dim == 3:
        plt.suptitle(f'Utfall av {rounds} partier Tre-i-rad på ett'
                     f' 3x3x3-bräde')
    if scenario == 1:
        plt.title('Spelare 1 slumpade sitt första drag.', fontsize = 8)
    elif scenario == 2:
        plt.title('Spelare 1 spelade sitt första drag i mitten.', fontsize = 8)
    plt.savefig('utfall.pdf')
    return
